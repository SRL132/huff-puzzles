
/** 
 *  SUM_ARRAY HUFF EXERCISE
 *
 * In this puzzle, the task is to simulate an array in Huff using the "exact" storage pattern as solidity. Expected functions can; 
 *      - Push numbers onto a array, 
 *      - Pop the last index from the array,
 *      - View what's stored at an index, 
 *      - Gets the length of the array, 
 *      - Write to an index if it is valid.
 *
 *      - Writes and reads outside of length revert. 
 *      - Popping off a zero length array reverts.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

 #define function pushh(uint256 num) payable returns()
 #define function popp() payable returns()
 #define function read(uint256 index) payable returns(uint256)
 #define function length() payable returns(uint256)
 #define function write(uint256 index, uint256 num) payable returns()

 #define error OutOfBounds()
 #define error ZeroArray()

 #define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xe0 shr

    dup1 __FUNC_SIG(popp) eq po jumpi
    dup1 __FUNC_SIG(pushh) eq pushh jumpi
    dup1 __FUNC_SIG(read) eq read jumpi
    dup1 __FUNC_SIG(length) eq length jumpi
    dup1 __FUNC_SIG(write) eq write jumpi
    0x00 0x00 revert
    po:
        POP() 
    pushh:
        PUSHH()
    read:
        READ()
    write:
        WRITE()
    length:
        LENGTH()
 }

    #define macro POP() = takes(0) returns(0) {
        0x00 sload   // [length]
        dup1 iszero err jumpi  // [length]
        0x01 swap1 sub  // [length-1]
        0x00 sstore  // []
        0x00 0x00 return

        err:
        __ERROR(ZeroArray)
        0x00 mstore
        0x20 0x00 revert
    }
//REVISE
    #define macro PUSHH() = takes(0) returns(0) {
        0x00 sload  // [length]
        dup1 0x01 add  // [length+1]
        0x00 sstore  // []  --Store the new length
        0x20 mul 0x20 add // [slot, length*20+20]
        0x04 calldataload swap1 // [num]
        sstore   // []  --Store the number in the corresponding new slot
        0x00 0x00 return
    }

    #define macro READ() = takes(0) returns(0) {
        0x04 calldataload  // [index]
        0x20 mul  // [index*32]
        0x20 add //[index*32+32 bytes]  -->first slot is the length, so we start from 32 bytes (0x20)
        sload  // [value]
        dup1 0x00 sload gt continue jumpi  // [value]

        __ERROR(OutOfBounds)
        0x00 mstore
        0x20 0x00 revert

        continue:
          0x00 mstore
          0x20 0x00 return
    }
//REVISE
    #define macro WRITE() = takes(0) returns(0) {
        0x00 sload
        0x04 calldataload  // [index]
        dup1 swap2 gt continue jumpi // [index] if length > index, continue
      
        dup1 0x00 sload gt continue jumpi  // [value]

        __ERROR(OutOfBounds)
        0x00 mstore
        0x20 0x00 revert

        continue:
          0x20 mul  // [index*32]
          0x20 add //[index*32+32 bytes]  -->first slot is the length, so we start from 32 bytes (0x20)
          0x24 calldataload  // [value]
          sload  // [value]
          0x00 0x00 return
    }

    #define macro LENGTH() = takes(0) returns(0) {
        0x00 sload  // [length]
        0x00 mstore
        0x20 0x00 return
    }