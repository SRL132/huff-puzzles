
/** 
 *  KECCAK HUFF EXERCISE
 *
 *  When writing solidity, we some times have to perform hashing operations like keccak256 etc
 *  
 *  The task is to write within the `MAIN` macro below, a function that returns the keccak256 of the calldata. Should handle zero calldata
 */
//Keccak256 is a cryptographic hash function that takes an input of an arbitrary length and produces a fixed-length output //of 256 bits. It is the function used to compute the hashes of Ethereum addresses, transaction IDs, and other important //values in the Ethereum ecosystem.
//REVISE
//    for i in range(0, len(padded_message), 64):
//        block = padded_message[i:i+64]
//        process_block(state, block)
 #define macro MAIN() = takes(0) returns(0) {
   // uint256 calldataSize = msg.data.length;
  calldatasize 0x00 //[offset, calldata_size]


   //for loop to store the calldata in memory
  loop:
    dup1 calldataload // [calldata_at_offset, offset, calldata_size]
    dup2 mstore // [offset, calldata_size]  -->store calldata in memory at offset
    0x20 add // [new_offset, calldata_size]
    dup1 dup2 gt loop jumpi // if new_offset > calldata_size, jump to next instruction //[offset, calldata_size] Q why does this comparison not work?

    //once everything is stored in memory, we can now hash the calldata
    pop 0x00 sha3

    0x00 mstore


  0x20 0x00 return
 }