/** 
 *  COUNT_TIME HUFF EXERCISE
 *
 *  The task is to write within the `MAIN` macro below, functions named `getTimeElapsed` and `getTimeUntil`.
 * 
 *  `getTimeElapsed` receives the uint256 parameter (_timestamp) and counts how much time elapsed since the provided _timestamp, it should return 0 if the provided timestamp is in the future 
 *  `getTimeUntil` receives uint256 parameter (_timestamp) and counts how much time remains until the provided _timestamp, it should return 0 if the provided timestamp is in the past
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

#define function getTimeElapsed(uint256) payable returns(uint256)
#define function getTimeUntil(uint256) payable returns(uint256)


#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xE0 shr 
   dup1 __FUNC_SIG(getTimeElapsed) eq gtTE jumpi
    __FUNC_SIG(getTimeUntil) eq gtTU jumpi
    0x00 0x00 revert
    gtTE:
        GET_TIME_ELAPSED()
    gtTU:
        GET_TIME_UNTIL()
}

#define macro GET_TIME_ELAPSED() = takes(0) returns(0) {
         0x04 calldataload   //[timestampArg]
         timestamp       //[timestamp, timestampArg, timestampArg]
         lt returnZero jumpi
         timestamp           // Push the current block timestamp onto the stack again
         0x04 calldataload   // Load the timestamp argument from calldata again
         swap1                      //[timestampArg, timestampArg, timestamp - timestampArg]
         sub
         0x00
         mstore
         0x20 0x00 return

        returnZero:
         0x00
         0x00 mstore
         0x20 0x00 return
}

#define macro GET_TIME_UNTIL() = takes(0) returns(0) {
    0x04 calldataload   // Load the timestamp argument from calldata
    timestamp           // Push the current block timestamp onto the stack
    gt returnZero jumpi // Compare the two timestamps; if the current timestamp is greater, jump to returnZero
    0x04 calldataload   // Load the timestamp argument from calldata again
    timestamp           // Push the current block timestamp onto the stack again
    swap1               // Swap the top two elements on the stack
    sub                 // Subtract the current block timestamp from the argument
    0x00 mstore         // Store the result in memory at position 0
    0x20 0x00 return    // Return 32 bytes from memory position 0

    returnZero:
    0x00                // Push 0 onto the stack
    0x00 mstore         // Store 0 in memory at position 0
    0x20 0x00 return    // Return 32 bytes from memory position 0
}